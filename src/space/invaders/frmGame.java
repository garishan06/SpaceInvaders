/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package space.invaders;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.util.List;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import javax.imageio.ImageIO;
import javax.swing.Timer;

/**
 *
 * @author gari2
 */
public class frmGame extends javax.swing.JFrame {

    /**
     * Creates new form frmGame
     */
    public frmGame() {
        initComponents();
        loadImages();
    }

    public static int tickDuration = 10; //1000 milliseconds (1 second)  

public final Timer timer = new Timer(tickDuration, new ActionListener() { // game timer
        public void actionPerformed(ActionEvent e) {
            
            spawnUFO();
            
           spaceship.move(shipDirection); 
            moveAliens();
            moveMissle();
            moveUFO();
            
            alienFire();
                        
            ShipCollision();
            missleCollision();
            barrierAMCollision();
            UFOCollision();            
            
            WaveCheck();
            loseCheck();

            updateLives();
            panDraw.repaint(); 
   
        }// end of timer
     });
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panDraw = new javax.swing.JPanel(){

            //paintComponent happens on object creation and when
            //any changes occur to the frame (size change, new objects added.
                // etc.)
            @Override // this means that we are replacing the old
            //method that is prebuilt with a new one.
            public void paintComponent(Graphics g) {
                super.paintComponent(g); //calls the old paintComponent method
                draw(g);//calls the draw method
            }
        };
        panInfo = new java.awt.Panel();
        waveCount_lbl = new javax.swing.JLabel();
        Wave_lbl = new javax.swing.JLabel();
        Lives_lbl1 = new javax.swing.JLabel();
        Score_lbl1 = new javax.swing.JLabel();
        scoreCount_lbl = new javax.swing.JLabel();
        liveCount_lbl = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 204, 204));
        setForeground(new java.awt.Color(255, 0, 0));
        setMinimumSize(new java.awt.Dimension(800, 800));
        setResizable(false);
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        panDraw.setBackground(new java.awt.Color(0, 0, 0));
        panDraw.setMaximumSize(new java.awt.Dimension(800, 600));
        panDraw.setMinimumSize(new java.awt.Dimension(800, 600));
        panDraw.setPreferredSize(new java.awt.Dimension(800, 600));

        javax.swing.GroupLayout panDrawLayout = new javax.swing.GroupLayout(panDraw);
        panDraw.setLayout(panDrawLayout);
        panDrawLayout.setHorizontalGroup(
            panDrawLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 800, Short.MAX_VALUE)
        );
        panDrawLayout.setVerticalGroup(
            panDrawLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );

        panInfo.setBackground(new java.awt.Color(255, 204, 204));

        waveCount_lbl.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        waveCount_lbl.setText("0");

        Wave_lbl.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        Wave_lbl.setText("Wave:");

        Lives_lbl1.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        Lives_lbl1.setText("Lives:");

        Score_lbl1.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        Score_lbl1.setText("Score: ");

        scoreCount_lbl.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        scoreCount_lbl.setText("0");

        liveCount_lbl.setFont(new java.awt.Font("OCR A Extended", 1, 24)); // NOI18N
        liveCount_lbl.setText("0");

        javax.swing.GroupLayout panInfoLayout = new javax.swing.GroupLayout(panInfo);
        panInfo.setLayout(panInfoLayout);
        panInfoLayout.setHorizontalGroup(
            panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panInfoLayout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(scoreCount_lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(231, 231, 231)
                .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Lives_lbl1)
                    .addComponent(liveCount_lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(waveCount_lbl, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Wave_lbl))
                .addGap(50, 50, 50))
            .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panInfoLayout.createSequentialGroup()
                    .addGap(16, 16, 16)
                    .addComponent(Score_lbl1)
                    .addContainerGap(674, Short.MAX_VALUE)))
        );
        panInfoLayout.setVerticalGroup(
            panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panInfoLayout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Lives_lbl1)
                    .addComponent(Wave_lbl))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(waveCount_lbl)
                    .addComponent(scoreCount_lbl)
                    .addComponent(liveCount_lbl))
                .addContainerGap(50, Short.MAX_VALUE))
            .addGroup(panInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(panInfoLayout.createSequentialGroup()
                    .addGap(37, 37, 37)
                    .addComponent(Score_lbl1)
                    .addContainerGap(72, Short.MAX_VALUE)))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(panDraw, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addComponent(panInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(panDraw, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addComponent(panInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
int keycode = evt.getKeyCode();

    if (((keycode == 37) || (keycode == 65)) && inGame){ // a or left arrow key
        shipDirection = -1;       //left

    } else if (((keycode == 39) || (keycode == 68)) && inGame){ // d or right arrow
        shipDirection = 1;    //right

    } else if (keycode == 40){
        shipDirection = 0;
    }
    
    if ((keycode == 27) && inGame){ // escape key
        //ends the game at any moment
        gameEnd();
        


    } else  if ((keycode == 10) && !inGame){ // enter key
        //starts the game
       gameStart();


    } else if ((keycode == 32) && inGame && !waveOver && !fired){ // space key
    //shoots a missle. Missles can only be shot one at a time
        fire();
        fired = true;
    }
panDraw.repaint();
    }//GEN-LAST:event_formKeyPressed
  //FINISH INTRO SCREEN
    
    
    //used to determine the game's state
    public  boolean inGame = false; 
    public boolean lose = false;    
    public boolean waveOver = false; 
    
    public boolean fired; // this will determine if a missle has been fired or not
    
    //game info variables:
    public int waveCount = 0;
    public int score = 0;
    
    //Images:
    public Image Alien1Image; 
    public Image Alien2Image; 
    public Image Alien3Image; 
    public Image UFOImage; 
    
    //Spaceship variables:
    int shipDirection = 0;
    
    // Alien variables:    
    // controls how often the aliens can move
    int movetimer = 0; 
    int moveDelay; 
    
    //direction variables
    int alienDx; 
    int alienDy; 
    
    boolean touchingEdge = false; // keeps track of whether or not the aliens have reached their max/min x position
    boolean down; // this will dictate when aliens can move downwards
    
    // controls how often the aliens can shoot
    int fireTimer = 0; 
    int fireDelay; 

    //UFO variables:
    boolean spawned = false;
    int [] scoreBoosts = {100, 150, 200, 300}; // all possible score boosts that the UFO will grant
    
    //controls how long it will take for the UFO to spawn
    int spawnDelay; 
    int spawnTimer;
    
    //Objects:
    SpaceShip spaceship = new SpaceShip(400, 550);
    
    Alien alien = new Alien(-400, 0,1, Alien1Image,Alien2Image,Alien3Image);
    
    
        List<Alien> aliens1 = new ArrayList<Alien>();  // shooting row 1 aliens
        List<Alien> aliens2 = new ArrayList<Alien>();  // spacesquid row 2 aliens
        List<Alien> aliens3 = new ArrayList<Alien>();  // spacesquid row 3 aliens
        List<Alien> aliens4 = new ArrayList<Alien>();  // regular  row 4 aliens
        List<Alien> aliens5 = new ArrayList<Alien>();  // regular row 5 aliens
      
        List <List<Alien>> allAliens = new ArrayList <List<Alien>>(); //List that will contain List for each row of aliens
     
        List<Missle> missles = new ArrayList<Missle>(); 
        List <Missle> alienMissles = new ArrayList <Missle>();
        
        List <Barrier> barriers = new ArrayList <Barrier>();
        
        List <UFO> UFOs = new ArrayList <UFO>();
        
        
    public void gameStart(){ // this method will set up the start of the game
        inGame = true;
        setVariables();
        setAliens();   
        setShip();
        setBarriers();
        updateWaveCount();
        updateScore();
        updateLives();
        timer.start();
        
    }

    public void gameEnd(){ // this method will stop the game and remove all game objects apart from the spaceship to 
        inGame = false;
        fired = false;
        spawned = false;
        score = 0;
        timer.stop();
        removeAliens();
        removeMissles();
        removeBarriers();
        removeUFO();
        updateWaveCount();
        updateScore();
    }
   
    //INITIALIZING METHODS:
        public void setVariables(){ // this method initializes all variables needed to start the game
            alien.rowSize = 11;
            spaceship.liveCount = 3;
            score = 0;
            lose = false;
            waveOver = false;
            fired = false;
            spawned = false;
            waveCount = 0;
            alien.minX = 25;
            alien.minY = 75;
            alien.maxX = 775;
            moveDelay = 100;
            fireDelay = 100;
            spawnDelay = (int) ((Math.random()* 40 + 15) * 100);
            alienDx = 1;
            alienDy = 0;
            spawnTimer = 0;
        }

        public void setAliens(){ // this sets up how the aliens will appear on the screen at the start of each wave

            //these variables dictate the x and y positions of each alien
           int xPos = alien.minX + 35; 
           int yPos = alien.minY;

           //this adds each row of aliens to the same list
           allAliens.add(aliens1);
           allAliens.add(aliens2);
           allAliens.add(aliens3);
           allAliens.add(aliens4);
           allAliens.add(aliens5);

           int i = 0; // used to determine which row the alien is in

           for (List <Alien> aliens : allAliens){ // these loops set the aliens up in their starting x and y co-ordinates
               for (int x = 0; x<alien.rowSize;x++){ 

                   aliens.add(new Alien(xPos, yPos, i + 1,Alien1Image,Alien2Image,Alien3Image));
                   xPos += 60;

               }
               i++;

                //once a row of aliens have been made, the x and y positions will update to get ready to position a new row of aliens
               xPos = alien.minX + 30;
               yPos += 50;
           }
        }//end of setAliens
    
    
       public void setShip(){
           //sets the spaceships original position and direction
           spaceship.x = 400;
           spaceship.y = 550;
           shipDirection = 0;
       }  
    
       public void setBarriers(){ //sets up the barriers in their starting position
            barriers.add(new Barrier (50, 520, 75, 10, 100));  
            barriers.add(new Barrier (350, 520, 100, 10, 100 ));
            barriers.add(new Barrier (675, 520, 75, 10, 100));
       }
       
       public void fire(){ //shoots a missile every time this method is called
            missles.add(new Missle(spaceship.x + 20, spaceship.y + 20, 1));
       }
    
       public void alienFire(){ // this controls how often the aliens will shoot missiles 
        if (!aliens1.isEmpty()){
            fireTimer++;
        
            if (fireTimer > fireDelay){ // this if statement delays the aliens from shooting for a certain period of time.
                fireTimer = 0;

                //sets up a local list containing all information regarding the row one shooting aliens so we do not interfere with the global list's contents
                List<Alien> aliens = new ArrayList<Alien>();  

                for (int x = 0; x < aliens1.size();x++){
                    aliens.add(aliens1.get(x));
                }
                
                Alien alien1 = aliens.get((int)(Math.random() * aliens.size()));
                alienMissles.add(new Missle (alien1.x + 15, alien1.y + 15, 2));
                aliens.remove(alien1);                                              // this line prevents one alien from shooting 2-3 missles at once

                    if (waveCount >= 4 && aliens1.size() > 1){ // after 5 waves, two aliens will shoot missles instead of one while there is more than one shooting alien left
      
                        Alien alien2 = aliens.get((int)(Math.random() * (aliens.size())));
                        alienMissles.add(new Missle (alien2.x + 15, alien2.y + 15, 2));
                        aliens.remove(alien2);

                        if (waveCount >=9  && aliens1.size() > 2){ // after 10 waves, three aliens will shoot missles instead of two while there is more than two shooting aliens left
      
                            Alien alien3 = aliens.get((int)(Math.random() * (aliens.size())));
                            alienMissles.add(new Missle (alien3.x + 15, alien3.y + 15, 2));                        
                            aliens.remove(alien3);
                            
                        }
                    }
            }
        }
       } // end of alienFire
 
       public void spawnUFO (){ // this method spawned in the UFO after a random amount of time
        if (!spawned){
            spawnTimer++;
            
            if (spawnTimer > spawnDelay){
                UFOs.add(new UFO (780,10,UFOImage));
                spawned = true;
                
            }
        }
       }
       
    //MOVING METHODS:
    public int findLeftMostAlien (){ // this method will find the x position of the alien closest to the left side of the screen
        int x = 0;
        int [] leftSideAliensX = new int [allAliens.size()]; // this array will represent the x positions of the left most alien in each row
        
        for (List <Alien> aliens : allAliens){
            leftSideAliensX [x] = aliens.get(0).x;
            x++;
        } 
        //this function sorts the array in order from least to greatest
        Arrays.sort(leftSideAliensX);
        
        return leftSideAliensX [0]; 
    }

    public int findRightMostAlien (){ // this method will find the x position of the alien closest to the right side of the screen
        int x = 0;
        int [] rightSideAliensX = new int [allAliens.size()]; // this array will represent the x positions of the right most alien in each row
        
        for (List <Alien> aliens : allAliens){
            rightSideAliensX [x] = aliens.get(aliens.size()-1).x + aliens.get(aliens.size()-1).width;
            x++;
        }
    
        //this function sorts the array in order from least to greatest
        Arrays.sort(rightSideAliensX);
        
        return rightSideAliensX [allAliens.size() - 1]; 
    }

     public void moveAliens (){
       if (!allAliens.isEmpty()){ // this if structure prevents an array error
         movetimer++;
        
         
        if (movetimer > moveDelay){ // this if structure ensures that the aliens only move after a certain period of time 
           movetimer = 0;
            int leftAlienX = findLeftMostAlien(); 
            int rightAlienX = findRightMostAlien();

            if ((leftAlienX <= alien.minX) || (rightAlienX >= alien.maxX)) { //if the rightmost/leftmost alien has reached/passed the minimum or maximum x position, 
                touchingEdge = true;                                         //this means it is too close to the edge and the touchingEdge variable will become true
            }

            if (touchingEdge){ // in this structure, the aliens are forced to move down once they get too close to the edge of the screen. After moving down 
                alienDy = 1;                // the aliens will then move in the direction opposite to their previous direction (if they used to move to the left they
                                            // will now move to the right) and will be broken out of this statement as they will no longer be near the edge.
                if (!down){ 
                    down = true;
                } else{
                    touchingEdge = false;
                    down = false;
                    alienDx*= -1;    
                }
            }

            for (List <Alien> aliens : allAliens ){ // this loop moves all the aliens
                for (Alien alien : aliens){
                    alien.move(alienDx, alienDy , down);
                }
            }
       }
       }
    }//end of moveAliens

    public void moveMissle(){
     //this moves the user's missles
        for (int x = 0; x < missles.size(); x++){
            missles.get(x).move();
            
            if (missles.get(x).y <-20){ // if the user's missles leave the screen they'll delete
            missles.remove(x);
            fired = false;
            }            
        }
        
        //this moves the alien's missles
        for (int x = 0; x < alienMissles.size(); x++){
            alienMissles.get(x).move();
            
            if (alienMissles.get(x).y > 600){ // if the aliens' missles leave the screen they'll delete
            alienMissles.remove(x);
            
            }
        }
    }
    
     public void moveUFO(){ // this method moves the UFO
           for (int x = 0; x < UFOs.size();x++){
             UFOs.get(x).move();

             if (UFOs.get(x).x < -80){ // if the UFO moves off the screen, it will delete
              UFOs.remove(x);
             }
        }  
       }
    
     
     //DRAWING METHODS:
     public void drawAliens(Graphics2D g2){ 
      for (List <Alien> aliens : allAliens ){
         for (Alien alien : aliens){
            alien.draw(g2);
        }
      }
     } // end of drawAliens
    
    public void drawMissles (Graphics2D g2){ 
        for (Missle missle : missles){
            missle.draw(g2);
        }
        for (Missle missle : alienMissles){
            missle.draw(g2);
        }
    } 
    
    public void drawBarriers(Graphics2D g2){
        for (Barrier barrier : barriers){
            barrier.draw(g2);
        }
       }
    
     public void drawUFO (Graphics2D g2){
        for (UFO ufo : UFOs){
            ufo.draw(g2);
        }
       }
    
    //REMOVE METHODS:
    public void removeMissles(){ // gets rid of all missles on the screen
        while (!alienMissles.isEmpty()){
        int i = 0;
            alienMissles.remove(i);
        }
        while (!missles.isEmpty()){
        int i = 0;
            missles.remove(i);
        }
    }
  
    public void removeAliens() {
        int rowCount = allAliens.size();
        
        for (List <Alien> aliens : allAliens ){ // these loops removes all aliens from each list within the allAliens list.
            
            int rowSize = aliens.size();
            
            for (int x = 0; x< rowSize; x++){   
                int i = 0;   
                aliens.remove(i);
            }
        }
        
        for (int x = 0; x< rowCount; x++){ // this loop removes each alien list within the allAliens list
        int i = 0;
        allAliens.remove(i);
        } 
    } // end of removeAliens
      
       public void removeBarriers () { // this method removes all barriers on screen
        while (!barriers.isEmpty()){
        int i = 0;
            barriers.remove(i);
        }
       }
       
        public void removeUFO(){ // this method removes all UFOs on screen
        while (!UFOs.isEmpty()){
        int i = 0;
            UFOs.remove(i);
        }
       }
       
    //COLLISION METHODS:    
    public void missleCollision(){ // detects collision between the user's missles and the aliens
 
      if (!missles.isEmpty()){ // this will only occur if the user has shot a missle
          for (List <Alien> aliens : allAliens){ // these loops run through each alien on the screen 
            
            for (int x = 0; x<aliens.size(); x++){ 
                
                if (missles.get(0).getBounds().intersects(aliens.get(x).getBounds())){ // if the missle hits an alien 
                                                                                                   // the score goes up depending on what type of alien was hit 
                    switch (aliens.get(x).alienType){                                         // and the missle and the hit alien will be removed from the screen
                        case 1: // 40 pts for row 1 aliens
                            score+= 40;
                            break;
                        case 2: // 20 pts for row 2 and 3 aliens
                            score+= 20;
                            break;
                        case 3:
                            score+= 20;
                            break;
                        case 4: // 10 pts for row 4 and 5 aliens
                            score+= 10;
                            break;
                        case 5:
                            score+= 10;
                            break;

                    }
                
                    updateScore();
                    missles.remove(0);
                    aliens.remove(x);

                    // if a row of aliens is empty, its list will be removed from the allAliens List
                    if (aliens.isEmpty()){
                    allAliens.remove(aliens);
                }
                
                fired = false;
                break;
                }
            }
            if (!fired){ 
                break;
            }
          }
      }
    } // end of missleCollision
    
     public void ShipCollision(){ // detects collision between the spaceship and the aliens' missiles
         
        Rectangle shipBounds = spaceship.getBounds();
        
        for (Missle missle: alienMissles){
            if (shipBounds.intersects(missle.getBounds())){ // if an alien missle touches the spaceship, it will delete and play the dying method 
                alienMissles.remove(missle);
                dying();
                break;
            }           
        }//end of for
        
    } //end of ShipCollision

     public void barrierAMCollision () { //checks for collisions between the barriers and the aliens' missles
         boolean hit = false; 
         
         if (!barriers.isEmpty() && !alienMissles.isEmpty()){
            for (Barrier barrier : barriers){
                for (Missle missle : alienMissles){

                    if (barrier.getBounds().intersects(missle.getBounds())){
                        hit = true;
                    }
                    
                    if (hit){
                        
                     alienMissles.remove(missle);
                        barrier.durability--;

                        if (barrier.durability % 10 == 0){
                             barrier.y++;
                             barrier.thickness--;
                         }
                        
                       
                        if (barrier.durability == 0){
                        barriers.remove(barrier);
                        }
                        break;
                    }
                }
                if (hit){
                break;
                }
            }
          }
       }

     public void UFOCollision(){ // checks for collisions between the UFO and the user's missles
           
         boolean hit = false;
       
         if (!UFOs.isEmpty() && !missles.isEmpty())
      
           for (UFO ufo : UFOs){
            for (Missle missle : missles){
                
                if (missle.getBounds().intersects(ufo.getBounds())){ // if a ufo is hit by the user's missle then both objects will delete, and the score will go up by 100,150,200 or 300 points
                    hit = true;
                    UFOs.remove(ufo);
                    missles.remove(missle);
                    score+= scoreBoosts [(int) (Math.random()*3)];
                    updateScore();
                    fired = false;
                    break;
                }
            }
            if (hit){
            break;
            }
        } 
       } // end of UFOCollision
    

     //GAME STATE METHODS:
     
     int newWaveTimer = 0; // used for wave over animations
     public void WaveCheck(){ // this method checks if a wave is over

         waveOver = false;
             
         if (allAliens.isEmpty()){ // if all aliens have been killed
             waveOver = true; // the wave will be over
         }
 
        if(waveOver){ 
            //removes any other unecessary objects from the screen
           removeMissles();
           removeUFO();
           newWaveTimer++;

           if (newWaveTimer> 300){
               
               newWaveTimer = 0;
               newWave();
           }
        } else {
            waveOver = false;
        }
     
     } // end of WaveCheck
     
     public void newWave(){ // this method will update the game once a wave is over
        //once a wave is over, the user will gain a life, their score increases by 1000, the wave count will increase, the aliens will move and shoot faster, 
        // and a new UFO will be allowed to spawn
      spaceship.liveCount++;
      waveCount++;
      updateWaveCount();
      score+= 1000;
      updateScore();
      setAliens();
      spaceship.updateSpeed(waveCount);
      moveDelay-= (moveDelay > 25) ? 7 : 0;
      fireDelay -= (fireDelay > 40) ? 5 : 0;
      alienDx = 1;
      spawned = false;
      spawnTimer = 0;
      spawnDelay = (int) ((Math.random()* 40 + 15) * 100);
     }

     public void loseCheck(){ // this checks if the aliens have reached the bottom of the screen. If so, the user will lose 
        if (!allAliens.isEmpty()){
        int x = 0;
        int [] bottomAliensY = new int [allAliens.size()]; // this array will represent the y positions of one alien in each row
        
        for (List <Alien> aliens : allAliens){
            bottomAliensY [x] = aliens.get(0).y;
            x++;
        }
        
        //this function sorts the array in order from least to greatest
        Arrays.sort(bottomAliensY);
        
       
        int bottomAlienY = bottomAliensY [allAliens.size()-1]; 
        
        if (bottomAlienY > 530){ // if the bottom most alien's y position has reached close enough to the bottom of the screen, then the user will lose and the game will end
            lose = true;
            gameEnd();
        }
        }
     } // end of lose check
     
       public void dying(){ // if the ship has been hit then it will lose a life
    spaceship.liveCount--;
    
    if (spaceship.liveCount == 0){ // if the spaceship has lost all its lives then the game will end
    lose = true;
        gameEnd();
    }
    }       
     
       
    // these methods update each of the game info variables at the bottom of the screen 
    public void updateScore(){
    scoreCount_lbl.setText(Integer.toString(score));
    }
     public void updateWaveCount(){
         if (inGame){
    waveCount_lbl.setText(Integer.toString(waveCount + 1));
         } else {
             waveCount_lbl.setText(Integer.toString(0));
         }
    }
      public void updateLives(){ // for this, switch it to images after
    liveCount_lbl.setText(Integer.toString(spaceship.liveCount));
    }
      
      
      public void loadImages(){ // loads all images used in the game
      
     try{ 
       Alien3Image = ImageIO.read(new File("normalAlien.png"));
   } catch (IOException e){
   System.out.println("File not Found");
   }  
      
     try{ 
       Alien1Image = ImageIO.read(new File("shootingAlien.png"));
   } catch (IOException e){ 
   System.out.println("File not Found");
   }
      
       try{
       Alien2Image = ImageIO.read(new File("squidAlien.png"));
   } catch (IOException e){ 
   System.out.println("File not Found");
   }
       
       try{
       UFOImage = ImageIO.read(new File("UFO.png"));
   } catch (IOException e){ 
   System.out.println("File not Found");
   }
      }
      
    public void draw (Graphics g){

        Graphics2D g2 = (Graphics2D) g;

        spaceship.draw(g2);
              
        if (inGame == true){ // while the game is in motion, the game objects will be drawn
          drawAliens(g2);
          drawMissles(g2);
          drawBarriers(g2);
          
         // g2.drawLine(alien.minX,0,alien.minX,600);
          //g2.drawLine(alien.maxX,0,alien.maxX,600);
          if (spawned){
          drawUFO(g2);
          }
          
          if (waveOver){ // this draws the text that appears at the end of each wave
              g2.setColor(Color.white);
              g2.setFont(new Font("OCR A Extended", Font.BOLD, 48));
            g2.drawString("WAVE OVER", 285, 250);
            g2.drawString("NEW WAVE INCOMING", 175, 300);
          } 
        } else {
        //draws other screens that show up when the game is over
         if (lose){ 
           showLoseScreen(g2);
           } else {
         showIntroScreen(g2);
         }
        }
    
    }    
  
   //GAME SCREEN METHODS: 
    public void showIntroScreen(Graphics2D g2){ //finish
     g2.setColor(Color.white);
              g2.setFont(new Font("OCR A Extended", Font.BOLD, 36));
          g2.drawString("SPACE INVADERS", 250, 250);
        
          g2.drawString("Press ENTER to start" , 170, 300);
          
          //draw a bunch of aliens n missles n stuff too
          
          //ask if it looks centered
          
    }
    
    public void showLoseScreen(Graphics2D g2){
        scoreCount_lbl.setText("0");
        
         g2.setColor(Color.white);
              g2.setFont(new Font("OCR A Extended", Font.BOLD, 36));
          g2.drawString("YOU LOSE", 295, 250);
          g2.drawString("SCORE: " + score, 290, 300);
          g2.drawString("Press ENTER to try again" , 120, 350);
          
          //ask if it looks centered
    }
    
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(frmGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(frmGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(frmGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(frmGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        
        /* Create and display the form */
        
        
        
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new frmGame().setVisible(true);
                
                
                 
               
                
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel Lives_lbl1;
    private javax.swing.JLabel Score_lbl1;
    private javax.swing.JLabel Wave_lbl;
    private javax.swing.JLabel liveCount_lbl;
    private javax.swing.JPanel panDraw;
    private java.awt.Panel panInfo;
    public javax.swing.JLabel scoreCount_lbl;
    public javax.swing.JLabel waveCount_lbl;
    // End of variables declaration//GEN-END:variables
}
